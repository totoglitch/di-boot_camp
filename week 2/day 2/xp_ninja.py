# -*- coding: utf-8 -*-
"""xp ninja

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1PJktoWCggpynoVIuojeJmhYBXzHRiP6v

Exercise 1 : Conway’s Game of Life
What you will create
Conway's Game of Life



Instructions
These are the rules of the Game of Life (as stated in Wikipedia):

The universe of the Game of Life is an infinite, two-dimensional orthogonal grid of square cells, each of which is in one of two possible states, alive or dead, (or populated and unpopulated, respectively).

Every cell interacts with its eight neighbours, which are the cells that are horizontally, vertically, or diagonally adjacent. At each step in time, the following transitions occur:

Any live cell with fewer than two live neighbours dies, as if by underpopulation.
Any live cell with two or three live neighbours lives on to the next generation.
Any live cell with more than three live neighbours dies, as if by overpopulation.
Any dead cell with exactly three live neighbours becomes a live cell, as if by reproduction.
Using these rules, implement the Game. (Hint: use Classes !!!!)
Use a few different initial states to see how the game ends.

Notes:

Display the grid after each generation
The end of the game is fully determined by the initial state. So have it pass through your program and see how it ends.
Be creative, but use classes
The game can have fixed borders and can also have moving borders. First implement the fixed borders. Each “live” cell that is going out of the border, exits the game.
Bonus: Make the game with ever expandable borders, make the maximum border size a very large number(10,000) so you won’t cause a memory overflow
"""

import numpy as np

class GameOfLife:
    def __init__(self, rows, cols, initial_state=None):
        self.rows = rows
        self.cols = cols
        if initial_state is None:
            self.grid = np.random.randint(2, size=(rows, cols))
        else:
            self.grid = np.array(initial_state)

    def get_neighbors(self, row, col):
        neighbors = []
        for i in range(-1, 2):
            for j in range(-1, 2):
                if i == 0 and j == 0:
                    continue
                r = (row + i + self.rows) % self.rows
                c = (col + j + self.cols) % self.cols
                neighbors.append(self.grid[r, c])
        return neighbors

    def update_grid(self):
        new_grid = np.copy(self.grid)
        for row in range(self.rows):
            for col in range(self.cols):
                live_neighbors = sum(self.get_neighbors(row, col))
                if self.grid[row, col] == 1:
                    if live_neighbors < 2 or live_neighbors > 3:
                        new_grid[row, col] = 0
                else:
                    if live_neighbors == 3:
                        new_grid[row, col] = 1
        self.grid = new_grid

    def display_grid(self):
        for row in self.grid:
            print(''.join(['■' if cell == 1 else '□' for cell in row]))
        print()


# Example usage
rows, cols = 10, 10

# Example initial state (glider)
initial_state = [
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 1, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 1, 0, 0, 0, 0, 0, 0],
    [0, 1, 1, 1, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
]

game = GameOfLife(rows, cols, initial_state)

for _ in range(10):  # Run for 10 generations
    game.display_grid()
    game.update_grid()