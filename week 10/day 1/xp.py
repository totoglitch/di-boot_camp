# -*- coding: utf-8 -*-
"""xp

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1c1Fqq3fktLdKBZdkSZChuaiaw8fHhQFt

üåü Exercise 1: Building a Comprehensive Dataset for Employee Analysis
Create a temporary table that join all tables and create a new one using LEFT JOIN.
Create an unique identifier code between the columns ‚Äòemployee_id‚Äô and ‚Äòdate‚Äô and call it ‚Äòid‚Äô.
Convert the column ‚Äòdate‚Äô to DATE type because it was previously configured as TIMESTAMP.
Transform this new table into a dataset ‚Äúdf_employee‚Äù for analysis.
Hint :
"""

import pandas as pd

employees_data = {'employee_id': [1, 2, 3], 'department_id': [10, 20, 10], 'date': ['2024-01-15 00:00:00', '2024-02-20 00:00:00', '2024-03-10 00:00:00']}
employees = pd.DataFrame(employees_data)

departments_data = {'department_id': [10, 20], 'department_name': ['Sales', 'Marketing']}
departments = pd.DataFrame(departments_data)

salaries_data = {'employee_id': [1, 2, 3], 'salary': [60000, 70000, 65000]}
salaries = pd.DataFrame(salaries_data)


titles_data = {'employee_id': [1, 2, 3], 'title': ['Sales Associate', 'Marketing Manager', 'Sales Representative']}
titles = pd.DataFrame(titles_data)


# Perform the LEFT JOIN operations
df_employee = pd.merge(employees, departments, on='department_id', how='left')
df_employee = pd.merge(df_employee, salaries, on='employee_id', how='left')
df_employee = pd.merge(df_employee, titles, on='employee_id', how='left')

# Create the unique identifier 'id'
df_employee['id'] = df_employee['employee_id'].astype(str) + '_' + df_employee['date'].astype(str)

# Convert 'date' column to DATE type
df_employee['date'] = pd.to_datetime(df_employee['date']).dt.date


df_employee

""" Exercise 2: Cleaning Data for Consistency and Quality
1. run the following SQLite request and observe your new table.

SELECT * FROM df_employee;


2. Remove all unwanted spaces from all text columns using TRIM

Hint :

UPDATE df_employee
SET
id = TRIM(id),
...
...;


3. Check for NULL values and empty values.

SELECT *
FROM df_employee
WHERE id IS NULL
OR month_year IS NULL
OR employee_id IS NULL
...
....;


4. Delete rows of the detected missing values.

Hint :

DELETE FROM df_employee
WHERE salary = ' '
;

"""

for col in ['id', 'department_name', 'title']:
    if col in df_employee.columns:
        df_employee[col] = df_employee[col].astype(str).str.strip()

# Check for NULL and empty values (simulated)
# In a real database, you'd use SQL queries as shown in the instructions.
for col in df_employee.columns:
    print(f"Null values in {col}: {df_employee[col].isnull().sum()}")
    print(f"Empty strings in {col}: {(df_employee[col] == '').sum()}")

# Example: Removing rows where 'salary' is empty
df_employee = df_employee[df_employee['salary'] != ' ']

df_employee

"""Exercise 3 : Calculating Current Employee Counts by Company
How many employees do the companies have today?
Group them by company

"""

df_max_date = df_employee.loc[df_employee.groupby('employee_id')['date'].idxmax()]

# Group by department and count employees
current_employee_counts = df_max_date.groupby('department_name')['employee_id'].count()

current_employee_counts

""" Exercise 4 : Analyzing Employee Distribution by City and Over Time
What is the total number of employees each city? Add a percentage column
What is the total number of employees each month?
What is the average number of employees each month?

"""

import pandas as pd

import numpy as np
df_employee['city'] = np.random.choice(['New York', 'London', 'Paris', 'Tokyo'], size=len(df_employee))

# Total employees per city
employee_counts_by_city = df_employee.groupby('city')['employee_id'].count()
total_employees = employee_counts_by_city.sum()
employee_percentages_by_city = (employee_counts_by_city / total_employees) * 100

print("Employee Distribution by City:")
print(employee_counts_by_city)
print("\nPercentage of Employees per City:")
print(employee_percentages_by_city)

# Convert 'date' column to datetime objects (if not already)
df_employee['date'] = pd.to_datetime(df_employee['date'])

# Extract year and month
df_employee['year_month'] = df_employee['date'].dt.to_period('M')

# Total employees per month
employee_counts_by_month = df_employee.groupby('year_month')['employee_id'].count()
print("\nTotal Employees per Month:")
print(employee_counts_by_month)

# Average number of employees per month (assuming consistent employee count throughout the month, a simplification)
average_employees_per_month = employee_counts_by_month.mean()
print(f"\nAverage Number of Employees per Month: {average_employees_per_month:.2f}")

""" Exercise 5 : Analyzing Employment Trends and Salary Metrics
What is the minimum and maximum number of employees throughout all the months? In which months were they?
What is the monthly average number of employees by function group?
What is the annual average salary?

"""

import pandas as pd
# Minimum and maximum employee counts and corresponding months
min_employees = employee_counts_by_month.min()
min_employee_months = employee_counts_by_month[employee_counts_by_month == min_employees].index.tolist()
max_employees = employee_counts_by_month.max()
max_employee_months = employee_counts_by_month[employee_counts_by_month == max_employees].index.tolist()

print(f"\nMinimum number of employees: {min_employees} in {min_employee_months}")
print(f"Maximum number of employees: {max_employees} in {max_employee_months}")

# Monthly average employees by department (replace 'department_name' if your grouping column is different)
monthly_avg_by_department = df_employee.groupby(['year_month', 'department_name'])['employee_id'].count().groupby('department_name').mean()
print("\nMonthly Average Employees by Department:")
print(monthly_avg_by_department)

# Annual average salary (assuming 'salary' column exists)
# Convert salary column to numeric
df_employee['salary'] = pd.to_numeric(df_employee['salary'], errors='coerce')  # Handle potential errors
annual_avg_salary = df_employee['salary'].mean()
print(f"\nAnnual Average Salary: {annual_avg_salary:.2f}")